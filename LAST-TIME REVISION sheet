# FINAL, LAST-TIME REVISION sheet for Sliding Window. #
Save this. Read it once before exams/interviews. Thatâ€™s enough.

ğŸ§  SLIDING WINDOW â€” FINAL REVISION (UNFORGETTABLE)
1ï¸âƒ£ WHEN to use Sliding Window (NO THINKING)

Use it immediately if you see:
Subarray / Substring
Continuous elements
Max / Min / Longest / Smallest

ğŸ‘‰ If all 3 appear â†’ Sliding Window

2ï¸âƒ£ ONE CORE IDEA (REMEMBER FOREVER)

Donâ€™t recalculate. Reuse.

Window moves like this:

Add right

Remove left

3ï¸âƒ£ TWO TYPES (ONLY THESE)
ğŸ”¹ A) FIXED WINDOW

âœ” Window size = k is given

Examples

Max sum of subarray of size k

Average of size k

Pattern

window_sum = sum(arr[:k])
answer = window_sum

for i in range(k, n):
    window_sum += arr[i]
    window_sum -= arr[i-k]
    answer = max(answer, window_sum)


ğŸ§  Memory line:

Right enters, left exits

ğŸ”¹ B) VARIABLE WINDOW

âœ” Window size changes
âœ” Condition-based

Examples

Longest subarray with sum â‰¤ K

Smallest subarray with sum â‰¥ K

4ï¸âƒ£ GOLDEN TEMPLATE (MEMORIZE THIS)
left = 0
current = 0
answer = 0

for right in range(n):
    current += arr[right]      # expand

    while condition breaks:
        current -= arr[left]   # shrink
        left += 1

    answer = max(answer, right - left + 1)  # update


ğŸ§  Chant this:

Expand â†’ Check â†’ Shrink â†’ Update

5ï¸âƒ£ MOST IMPORTANT LINE (DO NOT FORGET)

Update answer AFTER shrinking

That is where people fail.

right - left + 1

6ï¸âƒ£ YOUR EXACT PROBLEM (FINAL FORM)
Longest Subarray with Sum â‰¤ K
left = 0
res = 0
max_len = 0

for right in range(n):
    res += arr[right]

    while res > k:
        res -= arr[left]
        left += 1

    max_len = max(max_len, right - left + 1)

print(max_len)


âœ” Works because all numbers are positive

7ï¸âƒ£ 10-SECOND DECISION RULE (EXAMS)

Ask yourself:

Continuous?

Subarray?

Optimize something?

âœ” YES â†’ Sliding Window
âŒ NO â†’ Not Sliding Window

8ï¸âƒ£ COMMON MISTAKES (AVOID THESE)

âŒ Updating answer before shrinking
âŒ Forgetting right - left + 1
âŒ Using sliding window with negative numbers (unless special case)

9ï¸âƒ£ ONE-LINE FINAL MEMORY LOCK ğŸ”’

Sliding Window = Add right, remove left, update length


ğŸ§  SUBARRAYS â€” UNFORGETTABLE FINAL REVISION
1ï¸âƒ£ ONE LINE THAT DEFINES EVERYTHING

A subarray is a CONTIGUOUS part of an array.

If elements are next to each other, itâ€™s a subarray.
If you can skip elements, it is NOT a subarray.

Array: [1, 2, 3, 4]

Subarrays:
[1], [2], [3], [4]
[1,2], [2,3], [3,4]
[1,2,3], [2,3,4]
[1,2,3,4]


âŒ [1,3] â†’ NOT a subarray
âœ… [2,3] â†’ subarray

2ï¸âƒ£ THE ONE TEST (NEVER FAIL THIS)

Ask yourself:

Can I draw this using one continuous box?

âœ” Yes â†’ Subarray
âŒ No â†’ Not subarray

3ï¸âƒ£ TOTAL NUMBER OF SUBARRAYS (LOCK THIS ğŸ”’)

For array size n:

Total subarrays = n Ã— (n + 1) / 2


Example:

n = 4 â†’ 4Ã—5/2 = 10 subarrays


ğŸ§  Memory trick:

1 + 2 + 3 + ... + n

4ï¸âƒ£ 3 COMMON QUESTION TYPES (100% COVERAGE)
ğŸ”¹ Type 1: PRINT / COUNT subarrays

Brute force (2 loops):

for i in range(n):
    for j in range(i, n):
        print(arr[i:j+1])


Used when:

Print all subarrays

Count subarrays

ğŸ”¹ Type 2: SUBARRAY with MAX / MIN / SUM / LENGTH

ğŸ‘‰ SLIDING WINDOW (you already mastered this)

Used when:

Maximum sum subarray

Longest subarray with condition

Smallest subarray with condition

ğŸ§  Trigger words:

Continuous + optimize

ğŸ”¹ Type 3: SUBARRAY SUM = K

ğŸ‘‰ Prefix Sum + HashMap

Used when:

Count subarrays with sum = K

Works even with negative numbers

ğŸ§  Trigger words:

Exact sum + negatives allowed

5ï¸âƒ£ DECISION TABLE (EXAM GOLD)
Question asks	Technique
Print all subarrays	2 loops
Max / Min / Longest / Smallest	Sliding Window
Sum = K (exact)	Prefix Sum
Continuous elements	Subarray
Can skip elements	Subsequence
6ï¸âƒ£ SUBARRAY vs SUBSEQUENCE (NEVER CONFUSE)
Feature	Subarray	Subsequence
Continuous	âœ… Yes	âŒ No
Order matters	âœ…	âœ…
Sliding window	âœ…	âŒ

ğŸ§  Memory:

Subarray = â€œsub-ARRAY â†’ stays togetherâ€

7ï¸âƒ£ MOST COMMON EXAM TRAPS ğŸš¨

âŒ Using sliding window with negative numbers
âŒ Confusing subarray with subset
âŒ Forgetting contiguity
âŒ Using 3 loops when 1 window works

8ï¸âƒ£ ONE GLANCE FLOW (REMEMBER THIS)
SUBARRAY QUESTION?
        â†“
Is it continuous?
        â†“ YES
Optimize?
        â†“ YES â†’ Sliding Window
        â†“ NO  â†’ 2 loops
Exact sum?
        â†“ YES â†’ Prefix Sum

9ï¸âƒ£ FINAL MEMORY LOCK ğŸ” (READ TWICE)

Subarray = continuous block
Optimize â†’ Sliding Window
Exact sum â†’ Prefix Sum


ğŸ§  GRAPH, BFS, DFS & QUEUE â€” FINAL REVISION SHEET
1ï¸âƒ£ WHAT IS A GRAPH? (NO CONFUSION)

A graph is nodes (vertices) connected by edges.

Examples:

Social network (people â†’ friends)

Road map (cities â†’ roads)

Internet (computers â†’ cables)

2ï¸âƒ£ GRAPH TYPES (REMEMBER THIS TABLE)
Type	Meaning
Undirected	A â€” B (both ways)
Directed	A â†’ B (one way)
Weighted	Edges have cost
Unweighted	No cost

ğŸ§  Memory:

Arrow = Directed, Number = Weighted

3ï¸âƒ£ GRAPH REPRESENTATION (EXAM FAVORITE)
ğŸ”¹ Adjacency List (MOST USED)
graph = {
  0: [1, 2],
  1: [0, 3],
  2: [0],
  3: [1]
}


âœ” Space efficient
âœ” Used in BFS & DFS

4ï¸âƒ£ BFS (Breadth-First Search)
ğŸ§  ONE LINE DEFINITION

BFS visits level by level (nearest first)

ğŸ”‘ DATA STRUCTURE

QUEUE

ğŸ”¹ BFS USE CASES

Shortest path (unweighted graph)

Level order traversal

Nearest node problems

ğŸ”¹ BFS TEMPLATE (MEMORIZE)
from collections import deque

queue = deque([start])
visited = set([start])

while queue:
    node = queue.popleft()

    for nei in graph[node]:
        if nei not in visited:
            visited.add(nei)
            queue.append(nei)


ğŸ§  Memory line:

Push back, pop front

5ï¸âƒ£ DFS (Depth-First Search)
ğŸ§  ONE LINE DEFINITION

DFS goes as deep as possible first

ğŸ”‘ DATA STRUCTURE

STACK (or recursion)

ğŸ”¹ DFS USE CASES

Path existence

Cycle detection

Connected components

ğŸ”¹ DFS TEMPLATE (RECURSION)
visited = set()

def dfs(node):
    visited.add(node)

    for nei in graph[node]:
        if nei not in visited:
            dfs(nei)


ğŸ§  Memory line:

Go deep, then backtrack

6ï¸âƒ£ BFS vs DFS (NEVER MIX THIS UP)
Feature	BFS	DFS
Data structure	Queue	Stack / Recursion
Order	Level by level	Depth first
Shortest path	âœ… Yes	âŒ No
Memory	More	Less

ğŸ§  One-liner:

Shortest path â†’ BFS

7ï¸âƒ£ QUEUE (SUPER IMPORTANT)
ğŸ”¹ Queue Rule

FIFO â€” First In, First Out

ğŸ”¹ Operations
enqueue â†’ append()
dequeue â†’ popleft()


ğŸ§  Memory:

Line at a ticket counter

8ï¸âƒ£ EXAM DECISION FLOW ğŸ”¥
Graph problem?
     â†“
Shortest / nearest?
     â†“ YES â†’ BFS
     â†“ NO
Path / cycle / connected?
     â†“ YES â†’ DFS

9ï¸âƒ£ MOST COMMON EXAM TRAPS ğŸš¨

âŒ Forgetting visited â†’ infinite loop
âŒ Using DFS for shortest path
âŒ Confusing stack & queue
âŒ Not marking visited early in BFS

ğŸ”Ÿ FINAL MEMORY LOCK ğŸ” (READ TWICE)

Graph = nodes + edges
BFS = Queue = Shortest
DFS = Stack = Depth
