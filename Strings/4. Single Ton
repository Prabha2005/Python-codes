Single Ton - Difficulty: Medium
For a given Binary Tree of type integer, print all the nodes without any siblings.

Input Format
The first and the only line of input will contain the node data, all separated by a single space. Since -1 is used as an indication whether the left or right node data exist for root, it will not be a part of the node data.

Constraints
1 <= N <= 10^5 Where N is the total number of nodes in the binary tree. Time Limit: 1 second

Output Format
The only line of output prints the node data in a top to down fashion with reference to the root. Node data in the right subtree will be printed first and then the left subtree. A single space will separate them all.

Sample Input 0
5 6 10 2 3 -1 -1 -1 -1 -1 9 -1 -1
Sample Output 0
9

Sample Input 1
1 2 -1 3 -1 -1 4 -1 7 6 8 -1 -1 9 -1 -1 -1
Sample Output 1
2 3 4 7 9

Python:
class TreeNode:
    def __init__(self, val = 0, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right

def create_node(nodes):
    if not nodes or nodes[0] == -1:
        return None
    root = TreeNode(nodes[0])
    queue = [root]
    i = 1
    
    while queue and i < len(nodes):
        curr = queue.pop(0)
        
        if i < len(nodes) and nodes[i] != -1:
            curr.left = TreeNode(nodes[i])
            queue.append(curr.left)
        i += 1
        
        if i < len(nodes) and nodes[i] != -1:
            curr.right = TreeNode(nodes[i])
            queue.append(curr.right)
        i += 1
    return root
        
            

singles = []
def preorder(root):
    
    if not root:
        return
    if root.left and not root.right:
        singles.append(root.left.val)
        
    if root.right and not root.left:
        singles.append(root.right.val)
    
    
    preorder(root.right)
    preorder(root.left)

    return singles

nodes = list(map(int, input().split()))
root = create_node(nodes)
preorder(root)
if singles:
    print(*singles)




â€‹
